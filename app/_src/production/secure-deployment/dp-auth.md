---
title: Authentication with the data plane proxy
content_type: reference
---

To obtain a configuration from the control-plane, a data plane proxy must authenticate itself. There are several authentication methods availble.

## Service Account Token

On Kubernetes, a data plane proxy proves its identity with the [Service Account Token](https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/#bound-service-account-token-volume) that is mounted in every pod.

Keep in mind that if you don't explicitly specify `serviceAccountTokenName` in Deployment, the Pod is run with the `default` Service Account Token in the Namespace.
This means that authentication scope is bound to a Namespace, so any Pod in the Namespace can authenticate as any other Pod in a Namespace.

To have a strict security bound to a Deployment, every Deployment should use unique Service Account Token.
On top of that, users should not be able to modify `serviceAccountTokenName` in `Deployment`. This can be achieved for example with [OPA Gatekeeper](https://open-policy-agent.github.io/gatekeeper/website/docs/).

Service Account Token is not bound to a mesh, see [data plane proxy membership](/docs/{{ page.release }}/production/secure-deployment/dp-membership/) how to restrict which Pods can join a mesh.

## Data plane proxy token

On Universal, a data plane proxy must be explicitly configured with a unique security token (data plane proxy token) that will be used to prove its identity.

The data plane proxy token is a [JWT token](https://jwt.io) that contains:

- Mesh to which data plane belongs (required)
- The name of a data plane proxy (optional)
- List of tags that are permitted to use (optional)
- Expiration date of the token (required, 10 years if not specified)

The Data plane proxy token is signed by a signing key that is autogenerated when Mesh is created.
Tokens are never stored in the control plane, the only thing that is stored are signing keys that are used to verify if a token is valid.
The signing key is RSA256 encrypted.

You can check for the signing key:

```sh
kumactl get secrets
```

which returns something like:

```
MESH      NAME                                    AGE
default   dataplane-token-signing-key-default-1   49s
```

### Usage

You can generate token either by REST API

```bash
curl -XPOST \
  -H "Content-Type: application/json" \
  --data '{"name": "dp-echo-1", "mesh": "default", "tags": {"kuma.io/service": ["backend", "backend-admin"]}, "validFor": "720h"}' \
  http://localhost:5681/tokens/dataplane
```

or by using `kumactl`

```bash
kumactl generate dataplane-token \
  --name dp-echo-1 \
  --mesh default \
  --tag kuma.io/service=backend,backend-admin \
  --valid-for 720h > /tmp/kuma-dp-echo1-token
```

The token should be stored in a file and then used when starting `kuma-dp`

```bash
kuma-dp run \
  --cp-address=https://127.0.0.1:5678 \
  --dataplane-file=dp-backend.yaml \
  --dataplane-token-file=/tmp/kuma-dp-echo-1-token
```

You can also pass Dataplane Token inline as `KUMA_DATAPLANE_RUNTIME_TOKEN` Environment Variable.

### Data Plane Proxy Token boundary

As we can see in the example above, we can generate a token by passing a `name`, `mesh`, and a list of tags.
The control plane will then verify the data plane proxy resources that are connecting to it against the token. This means we can generate a token by specifying:

- Only `mesh`. By doing so we can reuse the token for all dataplanes in a given mesh.
- `mesh` + `tag` (ex. `kuma.io/service`). This way we can use one token across all instances/replicas of the given service.
  Please keep in mind that we have to specify to include all the services that a data plane proxy is in charge of.
  For example, if we have a Dataplane with two inbounds, one valued with `kuma.io/service: backend` and one with `kuma.io/service: backend-admin`, we need to specify both values (`--tag kuma.io/service=backend,backend-admin`).
- `mesh` + `name` + `tag` (ex. `kuma.io/service`). This way we can use one token for one instance/replica of the given service.

### Token Revocation

{{site.mesh_product_name}} does not keep the list of issued tokens. Whenever the single token is compromised, we can add it to revocation list so it's no longer valid.

{% if_version gte:2.10.x %}
Authentication between the control plane and data planes is only checked at connection start. This means that when revoking a token after the data plane connects, the connection won't stop. The recommended action on token revocation is to either restart the control plane or the concerned data planes.
{% endif_version %}

Every token has its own ID which is available in payload under `jti` key. You can extract ID from token using jwt.io or [`jwt-cli`](https://www.npmjs.com/package/jwt-cli) tool. Here is example of `jti`

```
0e120ec9-6b42-495d-9758-07b59fe86fb9
```

Specify list of revoked IDs separated by `,` and store it as `Secret` named `dataplane-token-revocations-{mesh}`

{% tabs %}
{% tab Universal %}

```sh
echo "
type: Secret
mesh: default
name: dataplane-token-revocations-default
data: {{ revocations }}" | kumactl apply --var revocations=$(echo '0e120ec9-6b42-495d-9758-07b59fe86fb9' | base64) -f -
```

{% endtab %}
{% tab Kubernetes %}

```sh
REVOCATIONS=$(echo '0e120ec9-6b42-495d-9758-07b59fe86fb9' | base64) && echo "apiVersion: v1
kind: Secret
metadata:
  name: dataplane-token-revocations-default
  namespace: {{site.mesh_namespace}}
data:
  value: $REVOCATIONS
type: system.kuma.io/secret" | kubectl apply -f -
```

{% endtab %}
{% endtabs %}

### Signing key rotation

If the signing key is compromised, we must rotate it and all the tokens that was signed by it.

1. Generate new signing key
   The signing key is stored as a `Secret` with a name that looks like `dataplane-token-signing-key-{mesh}-{serialNumber}`.

   Make sure to generate the new signing key with a serial number greater than the serial number of the current signing key.

   {% capture tabs %}
   {% tabs %}
   {% tab Universal %}
   Check what is the current highest serial number.

   ```sh
   kumactl get secrets
   MESH      NAME                                    AGE
   default   dataplane-token-signing-key-default-1   49s
   ```

   In this case, the highest serial number is `1`. Generate a new signing key with a serial number of `2`

   ```sh
   echo "
   type: Secret
   mesh: default
   name: dataplane-token-signing-key-default-2
   data: {{ key }}" | kumactl apply --var key=$(kumactl generate signing-key) -f -
   ```

   {% endtab %}
   {% tab Kubernetes %}
   Check what is the current highest serial number.

   ```sh
   kubectl get secrets -n {{site.mesh_namespace}} --field-selector='type=system.kuma.io/secret'
   NAME                                 TYPE                    DATA   AGE
   dataplane-token-signing-key-mesh-1   system.kuma.io/secret   1      25m
   ```

   In this case, the highest serial number is `1`. Generate a new signing key with a serial number of `2`

   ```sh
   TOKEN="$(kumactl generate signing-key)" && echo "
   apiVersion: v1
   data:
     value: $TOKEN
   kind: Secret
   metadata:
     name: dataplane-token-signing-key-mesh-2
     namespace: {{site.mesh_namespace}}
   type: system.kuma.io/secret
   " | kubectl apply -f -
   ```

   {% endtab %}
   {% endtabs %}
   {% endcapture %}
   {{ tabs | indent }}

2. Regenerate tokens
   Create new data plane proxy tokens. These tokens are automatically created with the signing key that’s assigned the highest serial number, so they’re created with the new signing key.
   At this point, tokens signed by either new or old signing key are valid.

3. Remove the old signing key
   {% capture tabs %}
   {% tabs %}
   {% tab Universal %}
   ```sh
   kumactl delete secret dataplane-token-signing-key-default-1 --mesh=default
   ```
   {% endtab %}
   {% tab Kubernetes %}
   ```sh
   kubectl delete secret dataplane-token-signing-key-default-1 -n {{site.mesh_namespace}}
   ```
   {% endtab %}
   {% endtabs %}
   {% endcapture %}
   {{ tabs | indent }}
   All new connections to the control plane now require tokens signed with the new signing key.

### Token rotation

If you need to generate a new token for a `Dataplane` or you are using service account token projection on Kubernetes, it's possible to configure dynamic token reloading. To enable this behaviour, set the `kuma-cp` configuration property `dpServer.auth.enableReloadableTokens` to `true`. When you enable the property, `kuma-dp` detects changes to the token file, reloads the token and uses the new value when establishing a new connection to `kuma-cp`.{% if_version gte:2.7.x %} By the defaut, `enableReloadableTokens` feature is enabled on Kubernetes.{% endif_version %}


### Offline token issuing

In addition to the regular flow of generating signing keys, storing them in secret, and using them to sign tokens on the control plane, Kuma also offers offline signing of tokens.
In this flow, you can generate a pair of public and private keys and configure the control plane only with public keys for token verification.
You can generate all the tokens without running the control plane.

The advantages of this mode are:
* easier, more reproducible deployments of the control plane, and more in line with GitOps.
* potentially more secure setup, because the control plane does not have access to the private keys.

Here's how to use offline issuing

1. Generate a pair of signing keys

   The following commands generate standard RSA key of 2048 bits and outputs it in PEM-encoded format.
   You can use any external tool to generate a pair of keys.

   ```sh
   kumactl generate signing-key --format=pem > /tmp/key-private.pem
   kumactl generate public-key --signing-key-path=/tmp/key-private.pem > /tmp/key-public.pem
   ```

   The result should be similar to this output
   ```sh
   cat /tmp/key-private.pem /tmp/key-public.pem 
   -----BEGIN RSA PRIVATE KEY-----
   MIIEpAIBAAKCAQEAsS61a79gC4mkr2Ltwi09ajakLyUR8YTkJWzZE805EtTkEn/r
   ...
   htKtzsYA7yGlt364IuDybrP+PlPMSK9cQAmWRRZIcBNsKOODkAgKFA==
   -----END RSA PRIVATE KEY-----
   -----BEGIN RSA PUBLIC KEY-----
   MIIBCgKCAQEAsS61a79gC4mkr2Ltwi09ajakLyUR8YTkJWzZE805EtTkEn/rL2u/
   ...
   se7sx2Pt/NPbWFFTMGVFm3A1ueTUoorW+wIDAQAB
   -----END RSA PUBLIC KEY----- 
   ```

2. Configure the control plane with public key

   [Configure a control plane](/docs/{{ page.release }}/documentation/configuration) with the following settings
   ```yaml
   dpServer:
     authn:
       dpProxy:
         type: dpToken
         dpToken:
           enableIssuer: false # disable control plane token issuer that uses secrets
           validator:
             useSecrets: false # do not use signing key stored in secrets to validate the token
             publicKeys:
             - kid: "key-1"
               mesh: default
               key: |
                 -----BEGIN RSA PUBLIC KEY-----
                 MIIBCgKCAQEAsS61a79gC4mkr2Ltwi09ajakLyUR8YTkJWzZE805EtTkEn/rL2u/
                 ...
                 se7sx2Pt/NPbWFFTMGVFm3A1ueTUoorW+wIDAQAB
                 -----END RSA PUBLIC KEY-----
   ```

3. Use the private key to issue tokens offline

   The command is the same as with online signing, but with two additional arguments:
   * `--kid` - ID of the key that should be used to validate the token. This should match `kid` specified in the control plane configuration.
   * `--signing-key-path` - path to a PEM-encoded private key.

   ```sh
   kumactl generate dataplane-token \
     --name dp-echo-1 \
     --mesh default \
     --tag kuma.io/service=backend,backend-admin \
     --valid-for 720h > /tmp/kuma-dp-echo1-token \
     --signing-key-path /tmp/key-private.pem \
     --kid key-1
   ```

   You can also use any external system that can issue JWT tokens using `RS256` signing method with the following claims:
   * `Name` (string) - the name of the DPP
   * `Mesh` (string) - the name of the mesh
   * `Tags` (map of string to []string) - list of tags that are permitted to use 

#### Migration

You can use both offline and online issuing by keeping `dpServer.authn.dpProxy.dpToken.enableIssuer` to true.
You can use both secrets and public key static config validators by keeping `dpServer.authn.dpProxy.dpToken.validator.useSecrets` to true.

#### Management

Token revocation works the same when using both online and offline issuing.

Signing key rotation works similarly:
* generate another pair of signing keys
* configure a control plane with old and new public keys
* regenerate tokens for all existing data plane proxies with the new private key
* remove the old public key from the configuration


### Multizone

When running in multizone, mode we can generate data plane proxy token both on global and zone control plane.
If the deployment pipeline is configured to generate data plane proxy token before running the proxy, it can rely on the Zone CP. This way Global CP is not a single point of failure.
Signing key rotation or token revocation should be performed on the global control plane.

## None

We can turn off the authentication by setting `KUMA_DP_SERVER_AUTH_TYPE` to `none`.

{% warning %}
If we disable the authentication between the control plane and the data plane proxies, any data plane proxy will be able to impersonate any service, therefore this is not recommended in production.
{% endwarning %}
